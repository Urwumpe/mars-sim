/*
 * Mars Simulation Project
 * TabPanelComputing.java
 * @date 2023-08-09
 * @author Manny Kung
 */
package org.mars_sim.msp.ui.swing.unit_window.structure;

import java.awt.BorderLayout;

import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;

import org.mars.sim.tools.Msg;
import org.mars_sim.msp.core.structure.Settlement;
import org.mars_sim.msp.core.structure.building.BuildingManager;
import org.mars_sim.msp.ui.swing.ImageLoader;
import org.mars_sim.msp.ui.swing.MainDesktopPane;
import org.mars_sim.msp.ui.swing.StyleManager;
import org.mars_sim.msp.ui.swing.unit_window.TabPanel;
import org.mars_sim.msp.ui.swing.utils.AttributePanel;

/**
 * This is a tab panel for settlement's computing capability.
 */
@SuppressWarnings("serial")
public class TabPanelComputing
extends TabPanel {

	// default logger.

	private static final String COMPUTING_ICON = "computing";

	private JLabel powerDemandLabel;
	private JLabel percentUsageLabel;
	private JLabel cULabel;
	private JLabel entropyLabel;
	
	/** The Settlement instance. */
	private Settlement settlement;
	
//	/** The cache of total heat generated. */
//	private double heatGenCache;
//	/** The cache of total power generated by heat source. */	
//	private double powerGenCache;
//	private double eheatCache;
//	private double epowerCache;
//
//	private JTable heatTable ;
//
//	private JScrollPane heatScrollPane;
//	
//	private JCheckBox checkbox;
//
//	private JLabel heatGenTF;
//	private JLabel powerGenTF;
//	private JLabel electricEffTF;
//	private JLabel solarEffTF;
	
	/** Table model for heat info. */
//	private HeatTableModel heatTableModel;
	
	private BuildingManager manager;

//	private List<HeatSource> heatSources;
//	private List<Building> buildings;
	
	/**
	 * Constructor.
	 * 
	 * @param unit the unit to display.
	 * @param desktop the main desktop.
	 */
	public TabPanelComputing(Settlement unit, MainDesktopPane desktop) {
		// Use the TabPanel constructor
		super(
			Msg.getString("TabPanelComputing.title"), //$NON-NLS-1$
			ImageLoader.getIconByName(COMPUTING_ICON),
			Msg.getString("TabPanelComputing.title"), //$NON-NLS-1$
			desktop
		);
		settlement = unit;
	}
	
	@Override
	protected void buildUI(JPanel content) {
		
		manager = settlement.getBuildingManager();

//		buildings = manager.getComputingBuildings();

		JPanel topContentPanel = new JPanel();
		topContentPanel.setLayout(new BoxLayout(topContentPanel, BoxLayout.Y_AXIS));
		content.add(topContentPanel, BorderLayout.NORTH);
		
		// Prepare heat info panel.
		AttributePanel springPanel = new AttributePanel(4);
		content.add(springPanel, BorderLayout.NORTH);

		// Total Power Demand
		double powerDemand = manager.getTotalComputingPowerDemand();
		powerDemandLabel = springPanel.addTextField(Msg.getString("BuildingPanelComputation.powerDemand"),
				     StyleManager.DECIMAL_KW.format(powerDemand), Msg.getString("BuildingPanelComputation.powerDemand.tooltip"));

		// Total Usage
		double usage = manager.getComputingUsagePercent();
		percentUsageLabel = springPanel.addTextField(Msg.getString("BuildingPanelComputation.usage"),
					 			StyleManager.DECIMAL_PERC.format(usage), Msg.getString("BuildingPanelComputation.usage.tooltip"));

		// Peak Usage
		double peak = Math.round(manager.getPeakTotalComputing() * 1_000.0)/1_000.0;
		
		// Total CUs Available
		double cUs = Math.round(manager.getTotalCUsComputing() * 1_000.0)/1_000.0;
		
		String text = cUs + " / " + peak + " CUs";
		cULabel = springPanel.addTextField(Msg.getString("BuildingPanelComputation.computingUnit"),
				text, Msg.getString("BuildingPanelComputation.computingUnit.tooltip"));
	
		// Total Entropy
		double entropy = manager.getTotalEntropy();
		entropyLabel = springPanel.addTextField(Msg.getString("BuildingPanelComputation.entropy"),
	 			Math.round(entropy * 1_000.0)/1_000.0 + "", Msg.getString("BuildingPanelComputation.entropy.tooltip"));	
		
//		// Create scroll panel for the outer table panel.
//		heatScrollPane = new JScrollPane();
//		// increase vertical mousewheel scrolling speed for this one
//		heatScrollPane.getVerticalScrollBar().setUnitIncrement(16);
//		heatScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
//		content.add(heatScrollPane,BorderLayout.CENTER);
//		
//		// Prepare thermal control table model.
//		heatTableModel = new HeatTableModel(settlement);
//		
//		// Prepare thermal control table.
//		heatTable = new JTable(heatTableModel);
//		// Call up the building window when clicking on a row on the table
//		heatTable.addMouseListener(new UnitTableLauncher(getDesktop()));
//		
//		heatTable.setRowSelectionAllowed(true);
//		TableColumnModel heatColumns = heatTable.getColumnModel();
//		heatColumns.getColumn(0).setPreferredWidth(10);
//		heatColumns.getColumn(1).setPreferredWidth(150);
//		heatColumns.getColumn(2).setPreferredWidth(30);
//		heatColumns.getColumn(3).setPreferredWidth(40);
//		heatColumns.getColumn(4).setPreferredWidth(40);
//		
//		DefaultTableCellRenderer renderer = new DefaultTableCellRenderer();
//		renderer.setHorizontalAlignment(SwingConstants.RIGHT);
////		heatColumns.getColumn(1).setCellRenderer(renderer);
//		heatColumns.getColumn(2).setCellRenderer(renderer);
//		heatColumns.getColumn(3).setCellRenderer(renderer);
//		heatColumns.getColumn(4).setCellRenderer(renderer);
//		
//		// Resizable automatically when its Panel resizes
//		heatTable.setPreferredScrollableViewportSize(new Dimension(225, -1));
//		heatTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
//
//		// Add sorting
//		heatTable.setAutoCreateRowSorter(true);
//
//		heatScrollPane.setViewportView(heatTable);
	}

//	/**
//	 * Sets if non-generating buildings should be shown.
//	 * 
//	 * @param value true or false.
//	 */
//	private void setNonGenerating(boolean value) {
//		if (value)
//			buildings = manager.getSortedBuildings();
//		else
//			buildings = manager.getBuildingsWithThermal();
//		heatTableModel.update();
//	}
//
//	public double getAverageEfficiencySolarHeating() {
//		double eff_solar_heat = 0;
//		int i = 0;
//		Iterator<Building> iHeat = manager.getBuildingsWithThermal().iterator();
//		while (iHeat.hasNext()) {
//			Building building = iHeat.next();
//			heatSources = building.getThermalGeneration().getHeatSources();
//			Iterator<HeatSource> j = heatSources.iterator();
//			while (j.hasNext()) {
//				HeatSource heatSource = j.next();
//				if (heatSource instanceof SolarHeatSource) {
//					i++;
//					SolarHeatSource solarHeatSource = (SolarHeatSource) heatSource;
//					eff_solar_heat += solarHeatSource.getEfficiencySolarHeat();
//				}
//			}
//		}
//		// get the average eff
//		if (i > 0) {
//			eff_solar_heat = eff_solar_heat / i;
//		}
//		return eff_solar_heat;
//	}
//
//	public double getAverageEfficiencyElectricHeat() {
//
//		double eff_electric_heating = 0;
//		int i = 0;
//		Iterator<Building> iHeat = manager.getBuildingsWithThermal().iterator();
//		while (iHeat.hasNext()) {
//			Building building = iHeat.next();
//			heatSources = building.getThermalGeneration().getHeatSources();
//			Iterator<HeatSource> j = heatSources.iterator();
//			while (j.hasNext()) {
//				HeatSource heatSource = j.next();
//				if (heatSource instanceof ElectricHeatSource) {
//					i++;
//					ElectricHeatSource electricHeatSource = (ElectricHeatSource) heatSource;
//					eff_electric_heating += electricHeatSource.getEfficiency();
//				}
//			}
//		}
//		// get the average eff
//		if (i > 0) {
//			eff_electric_heating = eff_electric_heating / i;
//		}
//		return eff_electric_heating;
//		
//	}

	/**
	 * Updates the info on this panel.
	 */
	@Override
	public void update() {

		// Total Power Demand
		double powerDemand = manager.getTotalComputingPowerDemand();
		String power = StyleManager.DECIMAL_KW.format(powerDemand);
		
		if (!powerDemandLabel.getText().equalsIgnoreCase(power))
			powerDemandLabel.setText(power);
		
		// Total Usage
		double usage = manager.getComputingUsagePercent();
		percentUsageLabel.setText(StyleManager.DECIMAL_PERC.format(usage));
		
		// Peak Usage
		double peak = Math.round(manager.getPeakTotalComputing() * 1_000.0)/1_000.0;
		// Total CUs Available
		double cUs = Math.round(manager.getTotalCUsComputing() * 1_000.0)/1_000.0;
		
		String text = cUs + " / " + peak + " CUs";
		
		if (!cULabel.getText().equalsIgnoreCase(text))
			cULabel.setText(text);
		
		String entropy = Math.round(manager.getTotalEntropy() * 1_000.0)/1_000.0 + "";
		
		if (!entropyLabel.getText().equalsIgnoreCase(entropy))
			entropyLabel.setText(entropy);
		
		
		// Update thermal control table.
//		heatTableModel.update();
	}

//	/**
//	 * Internal class used as model for the thermal control table.
//	 */
//	private class HeatTableModel extends AbstractTableModel
//		implements UnitModel {
//
//		/** default serial id. */
//		private static final long serialVersionUID = 1L;
//
//		private Icon dotRed;
//		private Icon dotYellow;
//		private Icon dotGreen_full, dotGreen_half, dotGreen_quarter, dotGreen_threeQuarter;
//
//		private HeatTableModel(Settlement settlement) {
//			dotRed = ImageLoader.getIconByName("dot/red"); 
//			dotYellow = ImageLoader.getIconByName("dot/yellow"); 
//			dotGreen_full = ImageLoader.getIconByName("dot/green"); 
//			dotGreen_half = ImageLoader.getIconByName("dot/green_half"); 
//			dotGreen_quarter = ImageLoader.getIconByName("dot/green_quarter"); 
//			dotGreen_threeQuarter = ImageLoader.getIconByName("dot/green_threeQuarter");
//		}
//
//		public int getRowCount() {
//			return buildings.size();
//		}
//
//		public int getColumnCount() {
//			return 5;
//		}
//		
//		public Class<?> getColumnClass(int columnIndex) {
//			Class<?> dataType = super.getColumnClass(columnIndex);
//			if (columnIndex == 0) dataType = Icon.class;
//			else if (columnIndex == 1) dataType = Building.class;
//			else if (columnIndex == 2) dataType = Double.class;
//			else if (columnIndex == 3) dataType = Double.class;
//			else if (columnIndex == 4) dataType = Double.class;
//			return dataType;
//		}
//
//		public String getColumnName(int columnIndex) {
//			if (columnIndex == 0) return Msg.getString("TabPanelThermalSystem.column.s"); //$NON-NLS-1$
//			else if (columnIndex == 1) return Msg.getString("TabPanelThermalSystem.column.building"); //$NON-NLS-1$
//			else if (columnIndex == 2) return Msg.getString("TabPanelThermalSystem.column.temperature"); //$NON-NLS-1$
//			else if (columnIndex == 3) return Msg.getString("TabPanelThermalSystem.column.generated"); //$NON-NLS-1$
//			else if (columnIndex == 4) return Msg.getString("TabPanelThermalSystem.column.capacity"); //$NON-NLS-1$
//			else return null;
//		}
//
//		public Object getValueAt(int row, int column) {
//
//			Building building = buildings.get(row);
//			HeatMode heatMode = building.getHeatMode();
//
//			// if the building has thermal control system, display columns
//				if (column == 0) {
//					if (heatMode == HeatMode.HEAT_OFF) {
//						return dotYellow; 
//					}
//					else if (heatMode == HeatMode.ONE_EIGHTH_HEAT) {
//						return dotGreen_quarter;
//					}
//					else if (heatMode == HeatMode.QUARTER_HEAT) {
//						return dotGreen_quarter;
//					}
//					else if (heatMode == HeatMode.HALF_HEAT) {
//						return dotGreen_half;
//					}
//					else if (heatMode == HeatMode.THREE_QUARTER_HEAT) {
//						return dotGreen_threeQuarter;
//					}
//					else if (heatMode == HeatMode.FULL_HEAT) {
//						return dotGreen_full;
//					}
//					else if (heatMode == HeatMode.OFFLINE) {
//						return dotRed;
//					}
//					else return null;
//				}
//				else if (column == 1)
//					return buildings.get(row);
//				else if (column == 2)
//					// return temperature of the building;
//					return  Math.round(building.getCurrentTemperature()*10.0)/10.0;
//				else if (column == 3) {
//					if (heatMode == HeatMode.HEAT_OFF) {
//						return 0.0;
//					}
//					if (heatMode != HeatMode.FULL_HEAT 
//							|| heatMode == HeatMode.THREE_QUARTER_HEAT
//							|| heatMode == HeatMode.HALF_HEAT
//							|| heatMode == HeatMode.QUARTER_HEAT
//							|| heatMode == HeatMode.ONE_EIGHTH_HEAT
//							) {
//							ThermalGeneration heater = building.getThermalGeneration();
//							if (heater != null) {
//								return  Math.round(heater.getGeneratedHeat()*100.0)/100.0;
//							}
//							else
//								return 0;
//					}
//				}
//				else if (column == 4) {
//					double generatedCapacity = 0.0;
//					try {
//						generatedCapacity = building.getThermalGeneration().getHeatGenerationCapacity();
//					}
//					catch (Exception e) {}
//					return Math.round(generatedCapacity*100.0)/100.0;
//				}
//			return null;
//		}
//
//		public void update() {
//			heatScrollPane.validate();
//
//			fireTableDataChanged();
//		}
//
//		@Override
//		public Unit getAssociatedUnit(int row) {
//			return buildings.get(row);
//		}
//	}
	
	/**
	 * Prepares object for garbage collection.
	 */
	@Override
	public void destroy() {
		super.destroy();
		
		settlement = null;
		manager = null;
	}
}
